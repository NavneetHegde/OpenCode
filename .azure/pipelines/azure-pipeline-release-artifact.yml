# Version
variables:
  vmImage: 'windows-latest'
  buildConfiguration: 'Release'

# Trigger the build stage on any branch push
trigger:
  branches:
    include:
      - main
      - release/*
      - hotfix/*
      - feature/*
      - bugfix/*

# =======================
# Stage 1: Build and Test
# =======================
stages:
- stage: Build
  displayName: 'Build and Test'
  jobs:
  - job: Build
    displayName: 'Build Solution'
    pool:
      vmImage: '$(vmImage)'  # Use Windows 2019 image for the build

    steps:

    # Checkout source with full history for GitVersion
    - checkout: self
      persistCredentials: true  # needed to push tag
      
    # Install NuGet tool
    - task: NuGetToolInstaller@1
      displayName: 'Install NuGet'
      inputs:
        versionSpec: '6.13.2'
        checkLatest: true

    # Install GitVersion only if not already installed
    - powershell: |
        if (-not (dotnet tool list -g | Select-String -Pattern "GitVersion.Tool")) {
          Write-Host "GitVersion is not installed. Installing..."
          dotnet tool install --global GitVersion.Tool
        } else {
          Write-Host "GitVersion is already installed. Skipping installation."
        }
      displayName: 'Install GitVersion (if not installed)'
              
    # Run GitVersion and save output
    - script: |
        dotnet gitversion /config .azure/pipelines/GitVersion.yml /output buildserver
      displayName: 'Run GitVersion'

    # Debugging step to verify extracted version values
    - script: |
        echo "Version Major: $(GitVersion.Major)"
        echo "Version Minor: $(GitVersion.Minor)"
        echo "Version Patch: $(GitVersion.Patch)"
        echo "Version PreleaseTag: $(GitVersion.PreReleaseTag)"
        echo "Version BuildMetaData: $(GitVersion.BuildMetaData)"
        echo "Version BuildMetaData: $(GitVersion.Label)"
        echo "Full SemVer: $(GitVersion.FullSemVer)"
        echo "SemVer: $(GitVersion.SemVer)"
      displayName: 'Show Version Variables'
      
    # Build the solution
    - task: DotNetCoreCLI@2
      displayName: 'Build Solution'
      inputs:
        command: build
        projects: '**/*.sln'  # Build all project files
        arguments: '--configuration $(buildConfiguration) /p:Version=$(GitVersion.FullSemVer)'

    # Run unit tests and collect code coverage
    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests'
      inputs:
        command: test
        projects: '**/*Tests/*.csproj'  # Run tests from test projects
        arguments: '--configuration Release --collect:"Code Coverage" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura'
    
    # Publish code coverage results
    - task: PublishCodeCoverageResults@2
      displayName: 'Publish Code Coverage Results'
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(Agent.TempDirectory)/**/*.cobertura.xml'
    
    # Pack the solution into a NuGet package
    - task: DotNetCoreCLI@2
      displayName: 'Pack NuGet Package'
      inputs:
        command: pack
        configuration: 'Release'
        packagesToPack: '**/*.csproj'
        arguments: '--configuration $(buildConfiguration) /p:PackageVersion=$(GitVersion.NuGetVersionV2)'
        versioningScheme: 'off'
        includes: '**/*.csproj'
        excludes: '**/*Tests/*.csproj'

  # Tag the repo with computed GitVersion.FullSemVer
    - script: |
        git config user.email "build@local"
        git config user.name "Azure Pipelines"
        git tag v$(GitVersion.FullSemVer)
        git push origin v$(GitVersion.FullSemVer)
      displayName: 'Tag the repository'
      condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    
    # # Publish the generated NuGet package as an artifact
    # - task: PublishBuildArtifacts@1
    #   displayName: 'Publish Artifact (NuGet)'
    #   inputs:
    #     pathToPublish: '$(Build.ArtifactStagingDirectory)'
    #     artifactName: 'drop'

# # =======================
# # Stage 2: QA Environment
# # =======================
# - stage: QA
#   displayName: 'Deploy to QA'
#   dependsOn: Build
#   #condition: and(succeeded(), or(startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/'), startsWith(variables['Build.SourceBranch'], 'refs/heads/release')))

#   jobs:
#   - deployment: DeployToQA
#     displayName: 'Deploy to QA Environment'
#     environment: QA  # Azure DevOps environment for QA
#     pool:
#       vmImage: '$(vmImage)'

#     strategy:
#       runOnce:
#         deploy:
#           steps:
#             - task: NuGetToolInstaller@1                            # Minimum required NuGet version: 4.8.0.5385+.
#               displayName: 'NuGet Tool Installer'
            
#             - task: NuGetAuthenticate@1
#               displayName: 'NuGet Authenticate'
            
#             - script: |
#                   nuget.exe push -Source "https://pkgs.dev.azure.com/navneethegde/OpenCode/_packaging/QAFeed/nuget/v3/index.json" -ApiKey az $(Pipeline.Workspace)\drop\*.nupkg
#               displayName: Push

#             - powershell: |
#                 $nupkg = Get-ChildItem "$(Pipeline.Workspace)\drop" -Filter *.nupkg | Select-Object -First 1
#                 if (-not $nupkg) { 
#                     throw "No .nupkg found!" 
#                 }

#                 Write-Host "FileName: $nupkg"

#                 $filename = $nupkg.BaseName  # e.g., MyLibrary.1.0.0-beta
#                 if ($filename -match '^(.*?)\.?([\d\.]+)-([a-zA-Z0-9]+)(\.(\d+))?$') {
#                     $name = $matches[1]
#                     $version = $matches[2]
#                     Write-Host "Package Name: $name"
#                     Write-Host "Package Version: $version"
        
#                     # Set the variables for next stages
#                     Write-Host "##vso[task.setvariable variable=PackageName]$name"
#                     Write-Host "##vso[task.setvariable variable=PackageVersion]$version"
#                 } else {
#                     throw "Filename '$filename' did not match expected pattern"
#                 }
#               displayName: 'Extract NuGet Package Info'


# # =======================
# # Stage 3: Pre-Production
# # =======================
# - stage: PreProd
#   displayName: 'Deploy to Pre-Prod'
#   dependsOn: QA
#   # condition: and(succeeded(), startsWith(variables['Build.SourceBranch'], 'refs/heads/release/'))

#   jobs:
#   - deployment: DeployToPreProd
#     displayName: 'Deploy to Pre-Prod Environment'
#     environment: PreProd  # Azure DevOps environment for Pre-Prod
#     pool:
#       vmImage: '$(vmImage)'

#     strategy:
#       runOnce:
#         deploy:
#           steps:
#             - task: NuGetToolInstaller@1                            # Minimum required NuGet version: 4.8.0.5385+.
#               displayName: 'NuGet Tool Installer'

#             - task: NuGetAuthenticate@1
#               displayName: 'Authenticate with NuGet Feed'

#             - powershell: |
#                 $nupkg = Get-ChildItem "$(Pipeline.Workspace)\drop" -Filter *.nupkg | Select-Object -First 1
#                 if (-not $nupkg) { 
#                     throw "No .nupkg found!" 
#                 }

#                 $filename = $nupkg.BaseName  # e.g., MyLibrary.1.0.0-beta
#                 if ($filename -match '^(.*?)\.?([\d\.]+)-([a-zA-Z0-9]+)(\.(\d+))?$') {
#                     $name = $matches[1]
#                     $version = $matches[2]
        
#                     # Set the variables for next stages
#                     Write-Host "##vso[task.setvariable variable=PackageName]$name"
#                     Write-Host "##vso[task.setvariable variable=PackageVersion]$version-Testfeature.1"
#                 } else {
#                     throw "Filename '$filename' did not match expected pattern"
#                 }


#             - task: PowerShell@2
#               displayName: 'Promote NuGet Package to Prerelease View'
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   $org = "https://pkgs.dev.azure.com/navneethegde/OpenCode"
#                   $project = "$(System.TeamProject)"
#                   $feed = "QAFeed"
#                   $packageName = "$(PackageName)"
#                   $packageVersion = "$(PackageVersion)"
#                   $view = "Prerelease"

#                   Write-Host "Promoting package '$packageName' version '$packageVersion' to view '$view'..."

#                   # Construct the URL for the API request
#                   $url = "${org}/_apis/packaging/feeds/${feed}/nuget/packages/${packageName}/versions/${packageVersion}?api-version=7.1"
#                   Write-Host $url

#                   # Prepare the authentication header using the system access token
#                   $pat = "$(System.AccessToken)"
#                   $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$pat"))
#                   $env:PAT = "$(System.AccessToken)"

#                   $headers = @{
#                       "Content-Type" = "application/json"
#                       Authorization = "Basic " + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$env:PAT"))
#                   }
  
#                   $body = @{
#                       views = @{
#                           op  = "add"
#                           path = "/views/-"
#                           value = "Prerelease"
#                       }
#                   } | ConvertTo-Json

#                   # Invoke the API to promote the package
#                   try {
#                       Invoke-RestMethod -Uri $url -Method Patch -Headers $headers -Body $body
#                       Write-Host "Package '$packageName' version '$packageVersion' promoted to '$view' view successfully."
#                   } catch {
#                       Write-Error "Error occurred while promoting package: $_"
#                   }

#               env:
#                 SYSTEM_ACCESSTOKEN: $(System.AccessToken)


#  # ===================
#  # Stage 4: Production
#  # ===================
# - stage: Prod
#   displayName: 'Deploy to Production'
#   dependsOn: PreProd
#   condition: succeeded()  # Run only if Pre-Prod deployment is successful

#   jobs:
#   - deployment: DeployToProd
#     displayName: 'Deploy to Production Environment'
#     environment: Prod  # Azure DevOps environment for Production
#     pool:
#       vmImage: '$(vmImage)'

#     strategy:
#       runOnce:
#         deploy:
#           steps:
#             - task: NuGetToolInstaller@1                            # Minimum required NuGet version: 4.8.0.5385+.
#               displayName: 'NuGet Tool Installer'

#             - task: NuGetAuthenticate@1
#               displayName: 'Authenticate with NuGet Feed'

#             - powershell: |
#                 $nupkg = Get-ChildItem "$(Pipeline.Workspace)\drop" -Filter *.nupkg | Select-Object -First 1
#                 if (-not $nupkg) { 
#                     throw "No .nupkg found!" 
#                 }

#                 $filename = $nupkg.BaseName  # e.g., MyLibrary.1.0.0-beta
#                 if ($filename -match '^(.*?)\.?([\d\.]+)-([a-zA-Z0-9]+)(\.(\d+))?$') {
#                     $name = $matches[1]
#                     $version = $matches[2]
        
#                     # Set the variables for next stages
#                     Write-Host "##vso[task.setvariable variable=PackageName]$name"
#                     Write-Host "##vso[task.setvariable variable=PackageVersion]$version-Testfeature.1"
#                 } else {
#                     throw "Filename '$filename' did not match expected pattern"
#                 }


#             - task: PowerShell@2
#               displayName: 'Promote NuGet Package to Release View'
#               inputs:
#                 targetType: 'inline'
#                 script: |
#                   $org = "https://pkgs.dev.azure.com/navneethegde/OpenCode"
#                   $project = "$(System.TeamProject)"
#                   $feed = "QAFeed"
#                   $packageName = "$(PackageName)"
#                   $packageVersion = "$(PackageVersion)"
#                   $view = "Prerelease"

#                   Write-Host "Promoting package '$packageName' version '$packageVersion' to view '$view'..."

#                   # Construct the URL for the API request
#                   $url = "${org}/_apis/packaging/feeds/${feed}/nuget/packages/${packageName}/versions/${packageVersion}?api-version=7.1"

#                   # Prepare the authentication header using the system access token
#                   $pat = "$(System.AccessToken)"
#                   $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$pat"))
#                   $env:PAT = "$(System.AccessToken)"

#                   $headers = @{
#                       "Content-Type" = "application/json"
#                       Authorization = "Basic " + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$env:PAT"))
#                   }
  
#                   $body = @{
#                       views = @{
#                           op  = "add"
#                           path = "/views/-"
#                           value = "Release"
#                       }
#                   } | ConvertTo-Json

#                   # Invoke the API to promote the package
#                   try {
#                       Invoke-RestMethod -Uri $url -Method Patch -Headers $headers -Body $body
#                       Write-Host "Package '$packageName' version '$packageVersion' promoted to '$view' view successfully."
#                   } catch {
#                       Write-Error "Error occurred while promoting package: $_"
#                   }

#               env:
#                 SYSTEM_ACCESSTOKEN: $(System.AccessToken)
