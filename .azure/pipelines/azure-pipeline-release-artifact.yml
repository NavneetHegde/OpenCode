# Version
variables:
  vmImage: 'windows-latest'

# Trigger the build stage on any branch push
trigger:
  branches:
    include:
      - feature/*

# Disable pipeline execution for regular pull requests
pr: none

# =======================
# Stage 1: Build and Test
# =======================
stages:
- stage: Build
  displayName: 'Build and Test'
  jobs:
  - job: Build
    displayName: 'Build Solution'
    pool:
      vmImage: '$(vmImage)'  # Use Windows 2019 image for the build

    steps:

    
    # Install NuGet tool
    - task: NuGetToolInstaller@1
      displayName: 'Install NuGet'
      inputs:
        versionSpec: '6.13.2'
        checkLatest: true

    # Install GitVersion only if not already installed
    - powershell: |
        if (-not (dotnet tool list -g | Select-String -Pattern "GitVersion.Tool")) {
          Write-Host "GitVersion is not installed. Installing..."
          dotnet tool install --global GitVersion.Tool
        } else {
          Write-Host "GitVersion is already installed. Skipping installation."
        }
      displayName: 'Install GitVersion (if not installed)'

            
    # Run GitVersion and save output
    - script: |
        dotnet gitversion /config .azure/pipelines/GitVersion.yml -output json > gitversion_output.json
      displayName: 'Run GitVersion with Config File'
    
    # Extract version information and set pipeline variables
    - powershell: |
        $gitVersion = Get-Content gitversion_output.json | ConvertFrom-Json
        Write-Host "##vso[task.setvariable variable=GitVersion.FullSemVer]$($gitVersion.FullSemVer)"
        Write-Host "##vso[task.setvariable variable=GitVersion.Major]$($gitVersion.Major)"
        Write-Host "##vso[task.setvariable variable=GitVersion.Minor]$($gitVersion.Minor)"
        Write-Host "##vso[task.setvariable variable=GitVersion.Patch]$($gitVersion.Patch)"
        Write-Host "##vso[task.setvariable variable=GitVersion.PreReleaseTag]$($gitVersion.PreReleaseTag)"
        Write-Host "##vso[task.setvariable variable=GitVersion.BuildMetaData]$($gitVersion.BuildMetaData)"
        Write-Host "##vso[task.setvariable variable=GitVersion.SemVer]$($gitVersion.SemVer)"
        Write-Host "##vso[task.setvariable variable=GitVersion.:Label]$($gitVersion.Label)"
        Write-Host "##vso[task.setvariable variable=VersionSuffix]$($gitVersion.PreReleaseTag)"
      displayName: 'Extract and Set GitVersion Variables'
        
    # Read VersionPrefix from Directory.Build.props
    - powershell: |
        [xml]$xml = Get-Content Directory.Build.props
        $versionPrefix = $xml.Project.PropertyGroup.VersionPrefix
        Write-Host "##vso[task.setvariable variable=VersionPrefix]$versionPrefix"
      displayName: 'Read VersionPrefix from Directory.Build.props'

    # Update VersionSuffix in Directory.Build.props
    - powershell: |
        (Get-Content Directory.Build.props) -replace '<VersionSuffix>.*</VersionSuffix>', "<VersionSuffix>$(GitVersion.PreReleaseTag)</VersionSuffix>" | Set-Content Directory.Build.props
      displayName: 'Update VersionSuffix in Directory.Build.props'

    # Debugging step to verify extracted version values
    - script: |
        echo "Version Major: $(GitVersion.Major)"
        echo "Version Minor: $(GitVersion.Minor)"
        echo "Version Patch: $(GitVersion.Patch)"
        echo "Version PreleaseTag: $(GitVersion.PreReleaseTag)"
        echo "Version BuildMetaData: $(GitVersion.BuildMetaData)"
        echo "Version BuildMetaData: $(GitVersion.Label)"
        echo "Full SemVer: $(GitVersion.FullSemVer)"
        echo "SemVer: $(GitVersion.SemVer)"
      displayName: 'Show Version Variables'
            
    # Commit Updated Directory.Build.props to Repository
    - task: PowerShell@2
      displayName: 'Commit Updated Directory.Build.props to Repository'
      inputs:
        targetType: 'inline'
        script: |
          # Configure Git
          git config --global user.email "build-agent@azuredevops.com"
          git config --global user.name "Azure DevOps Build Agent"
    
          # Ensure we're on the correct branch
          git fetch origin
          git checkout $(Build.SourceBranchName)
          git pull origin $(Build.SourceBranchName)
    
          # Check if Directory.Build.props changed
          if (-not (git diff --exit-code --quiet Directory.Build.props)) {
              Write-Host "No changes to commit."
              exit 0
          }
    
          # Add, Commit, and Push changes
          git add Directory.Build.props
          git commit -m "Update VersionSuffix to $($gitVersion.PreReleaseTag) [skip ci]"
          git push origin $(Build.SourceBranchName)
    
          Write-Host "Changes committed and pushed."
        
    # Build the solution
    - task: DotNetCoreCLI@2
      displayName: 'Build Solution'
      inputs:
        command: build
        projects: '**/*.sln'  # Build all project files
        arguments: '--configuration Release'

    # Run unit tests and collect code coverage
    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests'
      inputs:
        command: test
        projects: '**/*Tests/*.csproj'  # Run tests from test projects
        arguments: '--configuration Release --collect:"Code Coverage" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura'
    
    # Publish code coverage results
    - task: PublishCodeCoverageResults@2
      displayName: 'Publish Code Coverage Results'
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(Agent.TempDirectory)/**/*.cobertura.xml'

    
    # Pack the solution into a NuGet package
    - task: DotNetCoreCLI@2
      displayName: 'Pack NuGet Package'
      inputs:
        command: pack
        configuration: 'Release'
        packagesToPack: '**/*.csproj'
        includes: '**/*.csproj'
        excludes: '**/*Tests/*.csproj'

    
    # Publish the generated NuGet package as an artifact
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Artifact (NuGet)'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)'
        artifactName: 'drop'

# =======================
# Stage 2: QA Environment
# =======================
- stage: QA
  displayName: 'Deploy to QA'
  dependsOn: Build
  #condition: and(succeeded(), or(startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/'), startsWith(variables['Build.SourceBranch'], 'refs/heads/release')))

  jobs:
  - deployment: DeployToQA
    displayName: 'Deploy to QA Environment'
    environment: QA  # Azure DevOps environment for QA
    pool:
      vmImage: '$(vmImage)'

    strategy:
      runOnce:
        deploy:
          steps:
            - task: NuGetToolInstaller@1                            # Minimum required NuGet version: 4.8.0.5385+.
              displayName: 'NuGet Tool Installer'
            
            - task: NuGetAuthenticate@1
              displayName: 'NuGet Authenticate'
            
            - script: |
                  nuget.exe push -Source "https://pkgs.dev.azure.com/navneethegde/OpenCode/_packaging/QAFeed/nuget/v3/index.json" -ApiKey az $(Pipeline.Workspace)\drop\*.nupkg
              displayName: Push

            - powershell: |
                $nupkg = Get-ChildItem "$(Pipeline.Workspace)\drop" -Filter *.nupkg | Select-Object -First 1
                if (-not $nupkg) { 
                    throw "No .nupkg found!" 
                }

                Write-Host "FileName: $nupkg"

                $filename = $nupkg.BaseName  # e.g., MyLibrary.1.0.0-beta
                if ($filename -match '^(.*?)\.?([\d\.]+)-([a-zA-Z0-9]+)(\.(\d+))?$') {
                    $name = $matches[1]
                    $version = $matches[2]
                    Write-Host "Package Name: $name"
                    Write-Host "Package Version: $version"
        
                    # Set the variables for next stages
                    Write-Host "##vso[task.setvariable variable=PackageName]$name"
                    Write-Host "##vso[task.setvariable variable=PackageVersion]$version"
                } else {
                    throw "Filename '$filename' did not match expected pattern"
                }
              displayName: 'Extract NuGet Package Info'


# =======================
# Stage 3: Pre-Production
# =======================
- stage: PreProd
  displayName: 'Deploy to Pre-Prod'
  dependsOn: QA
  # condition: and(succeeded(), startsWith(variables['Build.SourceBranch'], 'refs/heads/release/'))

  jobs:
  - deployment: DeployToPreProd
    displayName: 'Deploy to Pre-Prod Environment'
    environment: PreProd  # Azure DevOps environment for Pre-Prod
    pool:
      vmImage: '$(vmImage)'

    strategy:
      runOnce:
        deploy:
          steps:
            - task: NuGetToolInstaller@1                            # Minimum required NuGet version: 4.8.0.5385+.
              displayName: 'NuGet Tool Installer'

            - task: NuGetAuthenticate@1
              displayName: 'Authenticate with NuGet Feed'

            - powershell: |
                $nupkg = Get-ChildItem "$(Pipeline.Workspace)\drop" -Filter *.nupkg | Select-Object -First 1
                if (-not $nupkg) { 
                    throw "No .nupkg found!" 
                }

                Write-Host "FileName: $nupkg"

                $filename = $nupkg.BaseName  # e.g., MyLibrary.1.0.0-beta
                if ($filename -match '^(.*?)\.?([\d\.]+)-([a-zA-Z0-9]+)(\.(\d+))?$') {
                    $name = $matches[1]
                    $version = $matches[2]
                    Write-Host "Package Name: $name"
                    Write-Host "Package Version: $version-Testfeature.1"
        
                    # Set the variables for next stages
                    Write-Host "##vso[task.setvariable variable=PackageName]$name"
                    Write-Host "##vso[task.setvariable variable=PackageVersion]$version"
                } else {
                    throw "Filename '$filename' did not match expected pattern"
                }


            - task: PowerShell@2
              displayName: 'Promote NuGet Package to Prerelease View'
              inputs:
                targetType: 'inline'
                script: |
                  $org = "https://pkgs.dev.azure.com/navneethegde/OpenCode"
                  $project = "$(System.TeamProject)"
                  $feed = "QAFeed"
                  $packageName = "$(PackageName)"
                  $packageVersion = "$(PackageVersion)"
                  $view = "Prerelease"

                  Write-Host "Promoting package '$packageName' version '$packageVersion' to view '$view'..."

                  # Construct the URL for the API request
                  $url = "${org}/_apis/packaging/feeds/${feed}/nuget/packages/${packageName}/versions/${packageVersion}-Testfeature.1?api-version=7.1"
                  Write-Host $url

                  # Prepare the authentication header using the system access token
                  $pat = "$(System.AccessToken)"
                  $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$pat"))

                  $headers = @{
                    "Content-Type" = "application/json"
                    "Authorization" = "Basic " + $base64AuthInfo
                  } | ConvertTo-Json

                  $body = @{
                      views = @{
                          op  = "add"
                          path = "/views/-"
                          value = "Prerelease"
                      }
                  } | ConvertTo-Json

                  # Invoke the API to promote the package
                  try {
                      Write-Host "Start request"
                      Write-Host $base64AuthInfo
                      Write-Host $pat
                      
                      #$response = Invoke-RestMethod -Uri $url -Method Put -Headers @{Authorization=("Basic $base64AuthInfo")} -ContentType "application/json"
                      $response = Invoke-RestMethod -Uri $url -Method Patch -Headers $headers -Body $body

                      Write-Host "Response $response"
                      # Check if the response was successful
                      if ($response) {
                          Write-Host "Package '$packageName' version '$packageVersion' promoted to '$view' view successfully."
                      } else {
                          Write-Error "Failed to promote package. No response received."
                      }
                  } catch {
                      Write-Error "Error occurred while promoting package: $_"
                  }

              env:
                SYSTEM_ACCESSTOKEN: $(System.AccessToken)


#  # ===================
#  # Stage 4: Production
#  # ===================
# - stage: Prod
#   displayName: 'Deploy to Production'
#   dependsOn: PreProd
#   condition: succeeded()  # Run only if Pre-Prod deployment is successful

#   jobs:
#   - deployment: DeployToProd
#     displayName: 'Deploy to Production Environment'
#     environment: Prod  # Azure DevOps environment for Production
#     pool:
#       vmImage: '$(vmImage)'

#     strategy:
#       runOnce:
#         deploy:
#           steps:
#           # Push the package to the Production NuGet feed
#           - task: NuGetCommand@2
#             displayName: 'Push to Production NuGet Feed'
#             inputs:
#               command: push
#               nuGetFeedType: external
#               publishFeedCredentials: 'Prod.Nuget'
#               arguments: '--configuration Release'
