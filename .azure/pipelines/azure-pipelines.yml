# Version
variables:
  vmImage: 'windows-latest'

# Trigger the build stage on any branch push
trigger:
  branches:
    include:
      - develop
      - release/*
      - feature/*
      - main

# Disable pipeline execution for regular pull requests
pr: none

# =======================
# Stage 1: Build and Test
# =======================
stages:
- stage: Build
  displayName: 'Build and Test'
  jobs:
  - job: Build
    displayName: 'Build Solution'
    pool:
      vmImage: '$(vmImage)'  # Use Windows 2019 image for the build

    steps:

    # Install NuGet tool
    - task: NuGetToolInstaller@1
      displayName: 'Install NuGet'
      inputs:
        versionSpec: '6.13.2'
        checkLatest: true

    # Install GitVersion
    - script: |
        dotnet tool install --global GitVersion.Tool
      displayName: 'Install GitVersion'
        
    # Run GitVersion and save output
    - script: |
        dotnet gitversion /config .azure/pipelines/GitVersion.yml -output json > gitversion_output.json
      displayName: 'Run GitVersion with Config File'
    
    # Extract version information and set pipeline variables
    - powershell: |
        $gitVersion = Get-Content gitversion_output.json | ConvertFrom-Json
        Write-Host "##vso[task.setvariable variable=GitVersion.FullSemVer]$($gitVersion.FullSemVer)"
        Write-Host "##vso[task.setvariable variable=GitVersion.Major]$($gitVersion.Major)"
        Write-Host "##vso[task.setvariable variable=GitVersion.Minor]$($gitVersion.Minor)"
        Write-Host "##vso[task.setvariable variable=GitVersion.Patch]$($gitVersion.Patch)"
        Write-Host "##vso[task.setvariable variable=GitVersion.PreReleaseTag]$($gitVersion.PreReleaseTag)"
        Write-Host "##vso[task.setvariable variable=VersionSuffix]$($gitVersion.PreReleaseTag)"
      displayName: 'Extract and Set GitVersion Variables'
        
    # Read VersionPrefix from Directory.Build.props
    - powershell: |
        [xml]$xml = Get-Content Directory.Build.props
        $versionPrefix = $xml.Project.PropertyGroup.VersionPrefix
        Write-Host "##vso[task.setvariable variable=VersionPrefix]$versionPrefix"
      displayName: 'Read VersionPrefix from Directory.Build.props'

    # Update VersionSuffix in Directory.Build.props
    - powershell: |
        (Get-Content Directory.Build.props) -replace '<VersionSuffix>.*</VersionSuffix>', "<VersionSuffix>$(GitVersion.PreReleaseTag)</VersionSuffix>" | Set-Content Directory.Build.props
      displayName: 'Update VersionSuffix in Directory.Build.props'

    # Debugging step to verify extracted version values
    - script: |
        echo "Version Prefix: $(GitVersion.Major)"
        echo "Version Prefix: $(GitVersion.Minor)"
        echo "Version Prefix: $(GitVersion.Patch)"
        echo "Version Prefix: $(GitVersion.PreReleaseTag)"
    
        echo "Version Prefix: $(GitVersion.FullSemVer)"
        echo "Full SemVer: $(GitVersion.FullSemVer)"
      displayName: 'Show Version Variables'
            
    # Commit Updated Directory.Build.props to Repository
    - task: PowerShell@2
      displayName: 'Commit Updated Directory.Build.props to Repository'
      inputs:
        targetType: 'inline'
        script: |
          # Configure Git
          git config --global user.email "build-agent@azuredevops.com"
          git config --global user.name "Azure DevOps Build Agent"
    
          # Ensure we're on the correct branch
          git fetch origin
          git checkout $(Build.SourceBranchName)
          git pull origin $(Build.SourceBranchName)
    
          # Check if Directory.Build.props changed
          if (-not (git diff --exit-code --quiet Directory.Build.props)) {
              Write-Host "No changes to commit."
              exit 0
          }
    
          # Add, Commit, and Push changes
          git add Directory.Build.props
          git commit -m "Update VersionSuffix to $($gitVersion.PreReleaseTag) [skip ci]"
          git push origin $(Build.SourceBranchName)
    
          Write-Host "Changes committed and pushed."
        
    # Build the solution
    - task: DotNetCoreCLI@2
      displayName: 'Build Solution'
      inputs:
        command: build
        projects: '**/*.sln'  # Build all project files
        arguments: '--configuration Release'

    # Run unit tests and collect code coverage
    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests'
      inputs:
        command: test
        projects: '**/*Tests/*.csproj'  # Run tests from test projects
        arguments: '--configuration Release --collect:"XPlat Code Coverage" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura'
    
    # Publish code coverage results
    - task: PublishCodeCoverageResults@2
      displayName: 'Publish Code Coverage Results'
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'

    # Pack the solution into a NuGet package
    - task: DotNetCoreCLI@2
      displayName: 'Pack NuGet Package'
      inputs:
        command: pack
        configuration: 'Release'
        packagesToPack: '**/*.csproj'
        includes: '**/*.csproj'
        excludes: '**/*Tests/*.csproj'
    
    # Publish the generated NuGet package as an artifact
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Artifact (NuGet)'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)'
        artifactName: 'drop'


# =======================
# Stage 2: QA Environment
# =======================
- stage: QA
  displayName: 'Deploy to QA'
  dependsOn: Build
  #condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'release'), startsWith(variables['System.PullRequest.SourceBranch'], 'feature/'))

  jobs:
  - deployment: DeployToQA
    displayName: 'Deploy to QA Environment'
    environment: QA  # Azure DevOps environment for QA
    pool:
      vmImage: '$(vmImage)'

    strategy:
      runOnce:
        deploy:
          steps:
            - task: NuGetToolInstaller@1                            # Minimum required NuGet version: 4.8.0.5385+.
              displayName: 'NuGet Tool Installer'

            - task: PowerShell@2
              displayName: 'List All Pipeline Variables'
              inputs:
                targetType: 'inline'
                script: 'Get-ChildItem Env: | Sort-Object Name | Format-Table -AutoSize'
            
            - task: NuGetAuthenticate@1
              displayName: 'NuGet Authenticate'
            
            - script: |
                  nuget.exe push -Source "https://pkgs.dev.azure.com/navneethegde/OpenCode/_packaging/QAFeed/nuget/v3/index.json" -ApiKey az $(Pipeline.Workspace)\drop\*.nupkg
              displayName: Push

# # =======================
# # Stage 3: Pre-Production
# # =======================
# - stage: PreProd
#   displayName: 'Deploy to Pre-Prod'
#   dependsOn: QA
#   condition: succeeded()  # Run only if QA deployment is successful

#   jobs:
#   - deployment: DeployToPreProd
#     displayName: 'Deploy to Pre-Prod Environment'
#     environment: PreProd  # Azure DevOps environment for Pre-Prod
#     pool:
#       vmImage: '$(vmImage)'

#     strategy:
#       runOnce:
#         deploy:
#           steps:
#           # Push the package to the Pre-Prod NuGet feed
#           - task: NuGetCommand@2
#             displayName: 'Push to Pre-Prod NuGet Feed'
#             inputs:
#               command: push
#               nuGetFeedType: external
#               publishFeedCredentials: 'PreProd.Nuget'
#               arguments: '--configuration Release'

#  # ===================
#  # Stage 4: Production
#  # ===================
# - stage: Prod
#   displayName: 'Deploy to Production'
#   dependsOn: PreProd
#   condition: succeeded()  # Run only if Pre-Prod deployment is successful

#   jobs:
#   - deployment: DeployToProd
#     displayName: 'Deploy to Production Environment'
#     environment: Prod  # Azure DevOps environment for Production
#     pool:
#       vmImage: '$(vmImage)'

#     strategy:
#       runOnce:
#         deploy:
#           steps:
#           # Push the package to the Production NuGet feed
#           - task: NuGetCommand@2
#             displayName: 'Push to Production NuGet Feed'
#             inputs:
#               command: push
#               nuGetFeedType: external
#               publishFeedCredentials: 'Prod.Nuget'
#               arguments: '--configuration Release'
