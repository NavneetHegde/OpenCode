# version 
variables:
  vmImage: 'windows-latest'
  VersionSuffix: 'rc-$(Build.BuildId)'  # Generates a unique version per build

# Trigger the build stage on any branch push
trigger:
  branches:
    include:
      - '*'  # Runs build on any branch

# Disable pipeline execution for regular pull requests
pr: none

# =======================
# Stage 1: Build and Test
# =======================
stages:
- stage: Build
  displayName: 'Build and Test'
  jobs:
  - job: Build
    displayName: 'Build Solution'
    pool:
      vmImage: '$(vmImage)'  # Use Windows 2019 image for the build

    steps:
    # Install NuGet tool
    - task: NuGetToolInstaller@1
      displayName: 'Install NuGet'
      inputs:
        versionSpec: '6.13.2'
        checkLatest: true

    - task: PowerShell@2
      displayName: 'Update VersionSuffix in Directory.Build.props'
      inputs:
        targetType: 'inline'
        script: |
          $propsFile = "Directory.Build.props"
          [xml]$xml = Get-Content $propsFile
    
          # Extract current VersionSuffix
          $versionSuffixNode = $xml.Project.PropertyGroup.VersionSuffix
          $versionSuffix = $versionSuffixNode
          Write-Host "Suffix: $versionSuffix"
    
          if ($versionSuffix -match "(.+).(\d+)$") {
              $prefix = $matches[1]
              $newVersionSuffix = "$prefix-$(Build.BuildId)"
             
              # Update VersionSuffix
              $versionSuffixNode = $newVersionSuffix
              $xml.Save($propsFile)
    
              Write-Host "Updated VersionSuffix to: $newVersionSuffix"
              Write-Host "##vso[task.setvariable variable=NewVersionSuffix]$newVersionSuffix"
          } else {
              Write-Host "Error: VersionSuffix format is invalid"
              exit 1
          }

    # Build the solution
    - task: DotNetCoreCLI@2
      displayName: 'Build Solution'
      inputs:
        command: build
        projects: '**/*.sln'  # Build all project files
        arguments: '--configuration Release'

    # Run unit tests and collect code coverage
    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests'
      inputs:
        command: test
        projects: '**/*Tests/*.csproj'  # Run tests from test projects
        arguments: '--configuration Release --collect:"XPlat Code Coverage" --results-directory "$(Build.ArtifactStagingDirectory)/TestResults"'
    
    # Publish code coverage results
    - task: PublishCodeCoverageResults@2
      displayName: 'Publish Code Coverage Results'
      inputs:
        codeCoverageTool: Cobertura
        summaryFileLocation: '$(Build.SourcesDirectory)/TestResults/**/coverage.cobertura.xml'

    # Pack the solution into a NuGet package
    - task: DotNetCoreCLI@2
      displayName: 'Pack NuGet Package'
      inputs:
        command: pack
        configuration: 'Release'
        versioningScheme: off
        packagesToPack: '**/*.csproj;!**/*Tests/*.csproj'
        version: $NewVersionSuffix
    
    # Publish the generated NuGet package as an artifact
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Artifact (NuGet)'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)'
        artifactName: 'drop'

# =======================
# Stage 2: QA Environment
# =======================
- stage: QA
  displayName: 'Deploy to QA'
  dependsOn: Build
  #condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'release'), startsWith(variables['System.PullRequest.SourceBranch'], 'feature/'))

  jobs:
  - deployment: DeployToQA
    displayName: 'Deploy to QA Environment'
    environment: QA  # Azure DevOps environment for QA
    pool:
      vmImage: '$(vmImage)'

    strategy:
      runOnce:
        deploy:
          steps:
          # Push the package to the QA NuGet feed
          - task: NuGetCommand@2
            displayName: 'Push to QA Internal Feed'
            inputs:
              command: push
              nuGetFeedType: internal
              publishVstsFeed: 'QAFeed'  # Replace with your Azure Artifacts feed name
              arguments: '--configuration Release'

# # =======================
# # Stage 3: Pre-Production
# # =======================
# - stage: PreProd
#   displayName: 'Deploy to Pre-Prod'
#   dependsOn: QA
#   condition: succeeded()  # Run only if QA deployment is successful

#   jobs:
#   - deployment: DeployToPreProd
#     displayName: 'Deploy to Pre-Prod Environment'
#     environment: PreProd  # Azure DevOps environment for Pre-Prod
#     pool:
#       vmImage: '$(vmImage)'

#     strategy:
#       runOnce:
#         deploy:
#           steps:
#           # Push the package to the Pre-Prod NuGet feed
#           - task: NuGetCommand@2
#             displayName: 'Push to Pre-Prod NuGet Feed'
#             inputs:
#               command: push
#               nuGetFeedType: external
#               publishFeedCredentials: 'PreProd.Nuget'
#               arguments: '--configuration Release'

# # ===================
# # Stage 4: Production
# # ===================
# - stage: Prod
#   displayName: 'Deploy to Production'
#   dependsOn: PreProd
#   condition: succeeded()  # Run only if Pre-Prod deployment is successful

#   jobs:
#   - deployment: DeployToProd
#     displayName: 'Deploy to Production Environment'
#     environment: Prod  # Azure DevOps environment for Production
#     pool:
#       vmImage: '$(vmImage)'

#     strategy:
#       runOnce:
#         deploy:
#           steps:
#           # Push the package to the Production NuGet feed
#           - task: NuGetCommand@2
#             displayName: 'Push to Production NuGet Feed'
#             inputs:
#               command: push
#               nuGetFeedType: external
#               publishFeedCredentials: 'Prod.Nuget'
#               arguments: '--configuration Release'
